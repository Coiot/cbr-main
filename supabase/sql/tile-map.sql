create table if not exists public.profiles (
  id uuid primary key references auth.users on delete cascade,
  email text,
  can_edit boolean default false,
  updated_at timestamptz default now()
);

create table if not exists public.tile_overrides (
  map_id text not null,
  col integer not null,
  row integer not null,
  payload jsonb not null,
  updated_at timestamptz default now(),
  updated_by uuid references auth.users,
  primary key (map_id, col, row)
);

create table if not exists public.tile_edits (
  id bigint generated by default as identity primary key,
  map_id text not null,
  col integer not null,
  row integer not null,
  payload jsonb not null,
  user_id uuid references auth.users,
  created_at timestamptz default now()
);

alter table public.profiles enable row level security;
alter table public.tile_overrides enable row level security;
alter table public.tile_edits enable row level security;

create policy "Profiles are readable by owner" on public.profiles
  for select using (auth.uid() = id);

create policy "Tile overrides are readable by everyone" on public.tile_overrides
  for select using (true);

create policy "Tile overrides are writable by editors" on public.tile_overrides
  for insert with check (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid()
        and profiles.can_edit = true
    )
  );

create policy "Tile overrides are updatable by editors" on public.tile_overrides
  for update using (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid()
        and profiles.can_edit = true
    )
  ) with check (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid()
        and profiles.can_edit = true
    )
  );

create policy "Tile edit logs are writable by editors" on public.tile_edits
  for insert with check (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid()
        and profiles.can_edit = true
    )
  );
